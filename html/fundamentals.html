<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>第一章 基础知识</title><link rel="stylesheet" href="css/hc-tutorial.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="HttpClient Tutorial"><link rel="up" href="index.html" title="HttpClient Tutorial"><link rel="prev" href="preface.html" title="Preface"><link rel="next" href="connmgmt.html" title="Chapter&nbsp;2.&nbsp;Connection management"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="banner"><a class="bannerLeft" href="http://www.apache.org/" title="Apache Software Foundation"><img style="border:none;" src="images/asf_logo_wide.gif"></a><a class="bannerRight" href="http://hc.apache.org/httpcomponents-core/" title="Apache HttpComponents Core"><img style="border:none;" src="images/hc_logo.png"></a><div class="clear"></div></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第一章 基础知识</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="preface.html">上一页</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="connmgmt.html">下一页</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Fundamentals"><div class="titlepage"><div><div><h2 class="title"><a name="fundamentals"></a>第一章 基础知识</h2></div></div></div>
    
    <div class="section" title="1.1.&nbsp;Request execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e37"></a>1.1.&nbsp;执行请求</h2></div></div></div>
        
        <p> 
		HttpClient 最基本的功能是执行 HTTP 方法。一个 HTTP 方法的执行过程包含一次或多次的 HTTP 请求/ HTTP 响应的交换，通常这个执行过程在 HttpClient 内部执行。用户要为执行过程提供一个请求对象，HttpClient 将这个请求对象发送给目标服务器，并返回一个对应的响应，如果执行失败则抛出异常。</p>
        
		<p> 
		HttpClient API 的主要入口点自然是 HttpClient 接口，这个接口中定义了上文所描述的约定。</p>
        <p>下面是一个请求执行过程的最简单例子：</p>
        <pre class="programlisting">
HttpClient httpclient = new DefaultHttpClient();
HttpGet httpget = new HttpGet("http://localhost/");
HttpResponse response = httpclient.execute(httpget);
HttpEntity entity = response.getEntity();
if (entity != null) {
    InputStream instream = entity.getContent();
    int l;
    byte[] tmp = new byte[2048];
    while ((l = instream.read(tmp)) != -1) {
    }
}
</pre>
        <div class="section" title="1.1.1.&nbsp;HTTP request"><div class="titlepage"><div><div><h3 class="title"><a name="d4e43"></a>1.1.1.&nbsp;HTTP 请求</h3></div></div></div>
            
            <p>
			所有的 HTTP 请求都包含一个方法名，一个请求 URI 和一个 HTTP 协议版本。</p>
            <p>
			HttpClient 支持所有 HTTP/1.1 规范中所定义的 HTTP 方法 <code class="literal">GET</code>, <code class="literal">HEAD</code>,
                    <code class="literal">POST</code>, <code class="literal">PUT</code>, <code class="literal">DELETE</code>,
                    <code class="literal">TRACE</code> and <code class="literal">OPTIONS</code>。对于每一个方法都有一个专门的类与之对应: <code class="classname">HttpGet</code>,
                    <code class="classname">HttpHead</code>, <code class="classname">HttpPost</code>,
                    <code class="classname">HttpPut</code>, <code class="classname">HttpDelete</code>,
                    <code class="classname">HttpTrace</code>, and <code class="classname">HttpOptions</code>.</p>
            <p>
			请求 URI 是一个统一资源标识符，其标识了那一个资源适用于这个请求。HTTP 请求 URI 包含协议名、主机名、端口（可选）、资源路径、查询（可选）和其他可选片段。</p>
            <pre class="programlisting">
HttpGet httpget = new HttpGet(
     "http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=");
</pre>
            <p>
			HttpClient 提供了一些有用的方法，用于简化请求URI的创建和修改。</p>
            <p>URI 可以通过程序进行拼装:</p>
            <pre class="programlisting">
URI uri = URIUtils.createURI("http", "www.google.com", -1, "/search", 
    "q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=", null);
HttpGet httpget = new HttpGet(uri);
System.out.println(httpget.getURI());
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
http://www.google.com/search?q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=
</pre>
            <p>查询字符串也可以通过单个参数来创建:</p>
            <pre class="programlisting">
List&lt;NameValuePair&gt; qparams = new ArrayList&lt;NameValuePair&gt;();
qparams.add(new BasicNameValuePair("q", "httpclient"));
qparams.add(new BasicNameValuePair("btnG", "Google Search"));
qparams.add(new BasicNameValuePair("aq", "f"));
qparams.add(new BasicNameValuePair("oq", null));
URI uri = URIUtils.createURI("http", "www.google.com", -1, "/search", 
    URLEncodedUtils.format(qparams, "UTF-8"), null);
HttpGet httpget = new HttpGet(uri);
System.out.println(httpget.getURI());
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
http://www.google.com/search?q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=
</pre>
        </div>
        <div class="section" title="1.1.2.&nbsp;HTTP response"><div class="titlepage"><div><div><h3 class="title"><a name="d4e72"></a>1.1.2.&nbsp;HTTP response</h3></div></div></div>
            
            <p>
			HTTP 响应是在服务端收到并解析请求之后发回客户端的消息。消息的第一行包含协议版本号，紧跟着是一个数字形式的状态码和它的文字式的表述。</p>
            <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
HttpStatus.SC_OK, "OK");

System.out.println(response.getProtocolVersion());
System.out.println(response.getStatusLine().getStatusCode());
System.out.println(response.getStatusLine().getReasonPhrase());
System.out.println(response.getStatusLine().toString());
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
HTTP/1.1
200
OK
HTTP/1.1 200 OK
</pre>
        </div>
        <div class="section" title="1.1.3.&nbsp;Working with message headers"><div class="titlepage"><div><div><h3 class="title"><a name="d4e78"></a>1.1.3.&nbsp;使用 HTTP 消息头</h3></div></div></div>
            
            <p>
			一个 HTTP 消息可能包含若干个头信息，这些头信息描述了这个消息的属性，例如内容长度、内容类型等等。HttpClient 提供了用于获得、添加、删除以及枚举头信息的一些方法。</p>
            <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie", 
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie", 
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");
Header h1 = response.getFirstHeader("Set-Cookie");
System.out.println(h1);
Header h2 = response.getLastHeader("Set-Cookie");
System.out.println(h2);
Header[] hs = response.getHeaders("Set-Cookie");
System.out.println(hs.length);
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
2
</pre>
            <p>
			获得给定类型的头信息的最有效方法是使用<code class="interfacename">HeaderIterator</code> 接口。</p>
            <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie", 
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie", 
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");

HeaderIterator it = response.headerIterator("Set-Cookie");

while (it.hasNext()) {
    System.out.println(it.next());
}
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
</pre>
            <p>
			他也提供了一些方法来解析 HTTP 消息，并转换成单独的头信息元素。</p>
            <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie", 
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie", 
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");

HeaderElementIterator it = new BasicHeaderElementIterator(
    response.headerIterator("Set-Cookie"));

while (it.hasNext()) {
    HeaderElement elem = it.nextElement(); 
    System.out.println(elem.getName() + " = " + elem.getValue());
    NameValuePair[] params = elem.getParameters();
    for (int i = 0; i &lt; params.length; i++) {
        System.out.println(" " + params[i]);
    }
}
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
c1 = a
path=/
domain=localhost
c2 = b
path=/
c3 = c
domain=localhost
</pre>
        </div>
        <div class="section" title="1.1.4.&nbsp;HTTP entity"><div class="titlepage"><div><div><h3 class="title"><a name="d4e93"></a>1.1.4.&nbsp;HTTP 实体</h3></div></div></div>
            
            <p>
			HTTP 消息可以携带和请求或者响应相关联的内容实体。在某些请求和响应中可以找到这些实体，因为它们是可选的。
			使用实体的请求是指那些用实体来关闭请求的那些 HTTP 请求。HTTP 规范中定义了两种实体关闭方法：<code class="literal">POST</code> and
                    <code class="literal">PUT</code>. 
					HTTP 响应通常是关闭实体内容的。但是也有例外：
                    <code class="literal">HEAD</code> method and <code class="literal">204 No Content</code>,
                    <code class="literal">304 Not Modified</code>, <code class="literal">205 Reset Content</code>
                responses.</p>
            <p>
			依据实体内容的来源，HttpClient 分为三种类型的实体：</p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="streamed:">
                        <b>流式:&nbsp;</b>
						内容是来源于数据流的，或者是实时产生的。这类实体特别包含从 HTTP 响应中获得的实体。流式实体通常是不可重复的。
                    </p>
                </li><li class="listitem">
                    <p title="self-contained:">
                        <b>自包含式:&nbsp;</b>
						自包含式实体的内容来自内存或者那些独立于连接或者其他实体的地方。自包含式实体一般是可重复的。这类实体多数情况下用作闭包 HTTP 请求。
                    </p>
                </li><li class="listitem">
                    <p title="wrapping:">
                        <b>包装式:&nbsp;</b>
						包装式实体的内容来自其他实体。
                    </p>
                </li></ul></div>
            <p>
			当从一个 HTTP 响应中分离出内容时，这个区别对于连接管理是很重要的。
				对于那些通过程序和 HttpClient 发送的请求实体，流式实体和自包含实体的区别并不重要。理论上考虑将不可重复的实体最为流式实体，将可重复实体作为自包含实体。
				</p>
            <div class="section" title="1.1.4.1.&nbsp;Repeatable entities"><div class="titlepage"><div><div><h4 class="title"><a name="d4e117"></a>1.1.4.1.&nbsp;可重复实体</h4></div></div></div>
                
                <p>
				如果说一个实体可重复的，意思是说它的内容可以多次被读取。	这仅仅是自包含实体的一种可能 (例如
                        <code class="classname">ByteArrayEntity</code> 或者
                        <code class="classname">StringEntity</code>)</p>
            </div>
            <div class="section" title="1.1.4.2.&nbsp;Using HTTP entities"><div class="titlepage"><div><div><h4 class="title"><a name="d4e122"></a>1.1.4.2.&nbsp;使用 HTTP 实体</h4></div></div></div>
                
                <p>
				因为一个实体即可能表示二进制内容也可能是字符内容，所以它要支持字符编码的处理（为了支持后者）。</p>
                <p>
				当执行带闭包内容的请求的时候，或者当请求成功时创建实体，并且响应体作为结果发回给客户端。</p>
                <p>
				若要从实体中读取内容，既可以通过返回<code class="classname">java.io.InputStream</code>的<code class="methodname">HttpEntity#getContent()</code>方法接收数据流，也可以通过给<code class="methodname">HttpEntity#writeTo(OutputStream)</code>方法提供一个输出流的方式，对于后者，如果全部内容已经输出到输出流中则返回。</p>
                <p>
				当已经从收到的消息中接收到实体的时候，方法<code class="methodname">HttpEntity#getContentType()</code> 和
                        <code class="methodname">HttpEntity#getContentLength()</code>可以用来读取如<code class="literal">Content-Type</code> 、
                        <code class="literal">Content-Length</code> 这样的头信息（如果它们有效的话）。因为<code class="literal">Content-Type</code> 头可以包含像 text/plain 或者 text/html 这样的 Mime 类型内容的字符编码，所以<code class="methodname">HttpEntity#getContentEncoding()</code> 用来读取这些信息。如果头信息无效，对于长度返回-1，对于内容返回NULL。如果  <code class="literal">Content-Type</code> 有效，<code class="interfacename">Header</code> 将被返回。</p>
                <p>
				当为发出的消息创建实体时，实体的创建者必须提供元数据。
					</p>
                <pre class="programlisting">
StringEntity myEntity = new StringEntity("important message", 
    "UTF-8");

System.out.println(myEntity.getContentType());
System.out.println(myEntity.getContentLength());
System.out.println(EntityUtils.getContentCharSet(myEntity));
System.out.println(EntityUtils.toString(myEntity));
System.out.println(EntityUtils.toByteArray(myEntity).length);
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
Content-Type: text/plain; charset=UTF-8
17
UTF-8
important message
17
</pre>
            </div>
        </div>
        <div class="section" title="1.1.5.&nbsp;Ensuring release of low level resources"><div class="titlepage"><div><div><h3 class="title"><a name="d4e143"></a>1.1.5.&nbsp;确保对底层资源的释放</h3></div></div></div>
            
            <p>
			当响应实体使用结束时，确保所有的实体内容被完全消费掉了是很重要的，这样该连接才能被安全地回到连接池中，分给其他挂起的请求使用。
			最简单的方式是调用<code class="methodname">HttpEntity#consumeContent()</code>来消费掉在请求流任何有效的实体内容。
		一旦 HttpClient 侦测到内容流已经到达末端，它会自动释放底层连接给连接管理器。<code class="methodname">HttpEntity#consumeContent()</code> 被调用多次也是安全的。
</p>
            <p>
			但是存在一种情况，当只需要获得整个响应内容的一小部分的时候，消费剩下的内容以及使连接可重用的性能损耗是非常大的，你可以调用<code class="methodname">HttpUriRequest#abort()</code>方法来终结请求。
			</p>
            <pre class="programlisting">
HttpGet httpget = new HttpGet("http://localhost/");
HttpResponse response = httpclient.execute(httpget);
HttpEntity entity = response.getEntity();
if (entity != null) {
    InputStream instream = entity.getContent();
    int byteOne = instream.read();
    int byteTwo = instream.read();
    // Do not need the rest
    httpget.abort();
}
</pre>
            <p>连接不会被释放，但是这个连接所持有的资源会将被重新分配。</p>
        </div>
        <div class="section" title="1.1.6.&nbsp;Consuming entity content"><div class="titlepage"><div><div><h3 class="title"><a name="d4e152"></a>1.1.6.&nbsp;消费实体内容</h3></div></div></div>
            
            <p>
			消费实体内容的推荐方式是使用 <code class="methodname">HttpEntity#getContent()</code> 或
                    <code class="methodname">HttpEntity#writeTo(OutputStream)</code> 方法。
 HttpClient 也提供了<code class="classname">EntityUtils</code> 类，它提供了一些静态方法使得从一个实体中读取内容和信息变得更加容易。
                你也可以通过它的一些方法以字符串或字节数组的方式获得整个的内容体，而不是直接从  <code class="classname">java.io.InputStream</code> 中读取。
				但是，强烈不推荐使用 <code class="classname">EntityUtils</code>，除非响应实体来自于可信任的 HTTP 服务器或者知道实体的长度限制。 
</p>
            <pre class="programlisting">
HttpGet httpget = new HttpGet("http://localhost/");
HttpResponse response = httpclient.execute(httpget);
HttpEntity entity = response.getEntity();
if (entity != null) {
    long len = entity.getContentLength();
    if (len != -1 &amp;&amp; len &lt; 2048) {
        System.out.println(EntityUtils.toString(entity));
    } else {
        // Stream content out
    }
}
</pre>
            <p>In some situations it may be necessary to be able to read entity content more than
                once. In this case entity content must be buffered in some way, either in memory or
                on disk. The simplest way to accomplish that is by wrapping the original entity with
                the <code class="classname">BufferedHttpEntity</code> class. This will cause the content of
                the original entity to be read into a in-memory buffer. In all other ways the entity
                wrapper will be have the original one.</p>
            <pre class="programlisting">
HttpGet httpget = new HttpGet("http://localhost/");
HttpResponse response = httpclient.execute(httpget);
HttpEntity entity = response.getEntity();
if (entity != null) {
    entity = new BufferedHttpEntity(entity);
}
</pre>
        </div>
        <div class="section" title="1.1.7.&nbsp;Producing entity content"><div class="titlepage"><div><div><h3 class="title"><a name="d4e164"></a>1.1.7.&nbsp;Producing entity content</h3></div></div></div>
            
            <p>HttpClient provides several classes that can be used to efficiently stream out
                content though HTTP connections. Instances of those classes can be associated with
                entity enclosing requests such as <code class="literal">POST</code> and <code class="literal">PUT</code>
                in order to enclose entity content into outgoing HTTP requests. HttpClient provides
                several classes for most common data containers such as string, byte array, input
                stream, and file: <code class="classname">StringEntity</code>,
                    <code class="classname">ByteArrayEntity</code>,
                <code class="classname">InputStreamEntity</code>, and
                <code class="classname">FileEntity</code>.</p>
            <pre class="programlisting">
File file = new File("somefile.txt");
FileEntity entity = new FileEntity(file, "text/plain; charset=\"UTF-8\"");

HttpPost httppost = new HttpPost("http://localhost/action.do");
httppost.setEntity(entity);
</pre>
            <p>Please note <code class="classname">InputStreamEntity</code> is not repeatable, because it
                can only read from the underlying data stream once. Generally it is recommended to
                implement a custom <code class="interfacename">HttpEntity</code> class which is
                self-contained instead of using generic <code class="classname">InputStreamEntity</code>.
                    <code class="classname">FileEntity</code> can be a good starting point.</p>
            <div class="section" title="1.1.7.1.&nbsp;Dynamic content entities"><div class="titlepage"><div><div><h4 class="title"><a name="d4e179"></a>1.1.7.1.&nbsp;Dynamic content entities</h4></div></div></div>
                
                <p>Often HTTP entities need to be generated dynamically based a particular
                    execution context. HttpClient provides support for dynamic entities by using
                        <code class="classname">EntityTemplate</code> entity class and
                        <code class="interfacename">ContentProducer</code> interface. Content producers
                    are objects which produce their content on demand, by writing it out to an
                    output stream. They are expected to be able produce their content every time
                    they are requested to do so. So entities created with
                        <code class="classname">EntityTemplate</code> are generally self-contained and
                    repeatable.</p>
                <pre class="programlisting">
ContentProducer cp = new ContentProducer() {
    public void writeTo(OutputStream outstream) throws IOException {
        Writer writer = new OutputStreamWriter(outstream, "UTF-8");
        writer.write("&lt;response&gt;");
        writer.write("  &lt;content&gt;");
        writer.write("    important stuff");
        writer.write("  &lt;/content&gt;");
        writer.write("&lt;/response&gt;");
        writer.flush();
    }
};
HttpEntity entity = new EntityTemplate(cp);
HttpPost httppost = new HttpPost("http://localhost/handler.do");
httppost.setEntity(entity);
</pre>
            </div>
            <div class="section" title="1.1.7.2.&nbsp;HTML forms"><div class="titlepage"><div><div><h4 class="title"><a name="d4e186"></a>1.1.7.2.&nbsp;HTML forms</h4></div></div></div>
                
                <p>Many applications frequently need to simulate the process of submitting an
                    HTML form, for instance, in order to log in to a web application or submit input
                    data. HttpClient provides special entity class
                        <code class="classname">UrlEncodedFormEntity</code> to facilitate the
                    process.</p>
                <pre class="programlisting">
List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;();
formparams.add(new BasicNameValuePair("param1", "value1"));
formparams.add(new BasicNameValuePair("param2", "value2"));
UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, "UTF-8");
HttpPost httppost = new HttpPost("http://localhost/handler.do");
httppost.setEntity(entity);
</pre>
                <p>This <code class="classname">UrlEncodedFormEntity</code> instance will use the so
                    called URL encoding to encode parameters and produce the following
                    content:</p>
                <pre class="programlisting">
param1=value1&amp;param2=value2
</pre>
            </div>
            <div class="section" title="1.1.7.3.&nbsp;Content chunking"><div class="titlepage"><div><div><h4 class="title"><a name="d4e194"></a>1.1.7.3.&nbsp;Content chunking</h4></div></div></div>
                
                <p>Generally it is recommended to let HttpClient choose the most appropriate
                    transfer encoding based on the properties of the HTTP message being transferred.
                    It is possible, however, to inform HttpClient that the chunk coding is preferred
                    by setting <code class="methodname">HttpEntity#setChunked()</code> to true. Please note
                    that HttpClient will use this flag as a hint only. This value well be ignored
                    when using HTTP protocol versions that do not support chunk coding, such as
                    HTTP/1.0.</p>
                <pre class="programlisting">
StringEntity entity = new StringEntity("important message", 
    "text/plain; charset=\"UTF-8\"");
entity.setChunked(true);
HttpPost httppost = new HttpPost("http://localhost/acrtion.do");
httppost.setEntity(entity);
</pre>
            </div>
        </div>
        <div class="section" title="1.1.8.&nbsp;Response handlers"><div class="titlepage"><div><div><h3 class="title"><a name="d4e199"></a>1.1.8.&nbsp;Response handlers</h3></div></div></div>
            
            <p>The simplest and the most convenient way to handle responses is by using
                    <code class="interfacename">ResponseHandler</code> interface. This method completely
                relieves the user from having to worry about connection management. When using a
                    <code class="interfacename">ResponseHandler</code> HttpClient will automatically
                take care of ensuring release of the connection back to the connection manager
                regardless whether the request execution succeeds or causes an exception.</p>
            <pre class="programlisting">
HttpClient httpclient = new DefaultHttpClient();
HttpGet httpget = new HttpGet("http://localhost/");

ResponseHandler&lt;byte[]&gt; handler = new ResponseHandler&lt;byte[]&gt;() {
    public byte[] handleResponse(
            HttpResponse response) throws ClientProtocolException, IOException {
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            return EntityUtils.toByteArray(entity);
        } else {
            return null;
        }
    }
};

byte[] response = httpclient.execute(httpget, handler);
</pre>
        </div>
    </div>
    <div class="section" title="1.2.&nbsp;HTTP execution context"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e205"></a>1.2.&nbsp;HTTP execution context</h2></div></div></div>
        
        <p>Originally HTTP has been designed as a stateless, response-request oriented protocol.
            However, real world applications often need to be able to persist state information
            through several logically related request-response exchanges. In order to enable
            applications to maintain a processing state HttpClient allows HTTP requests to be
            executed within a particular execution context, referred to as HTTP context. Multiple
            logically related requests can participate in a logical session if the same context is
            reused between consecutive requests. HTTP context functions similarly to
                <code class="interfacename">java.util.Map&lt;String, Object&gt;</code>. It is
            simply a collection of arbitrary named values. Application can populate context
            attributes prior to a request execution or examine the context after the execution has
            been completed.</p>
        <p>In the course of HTTP request execution HttpClient adds the following attributes to
            the execution context:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p title="'http.connection':">
                    <b>'http.connection':&nbsp;</b>
                    <code class="interfacename">HttpConnection</code> instance representing the
                        actual connection to the target server.
                </p>
            </li><li class="listitem">
                <p title="'http.target_host':">
                    <b>'http.target_host':&nbsp;</b>
                    <code class="classname">HttpHost</code> instance representing the connection
                        target.
                </p>
            </li><li class="listitem">
                <p title="'http.proxy_host':">
                    <b>'http.proxy_host':&nbsp;</b>
                    <code class="classname">HttpHost</code> instance representing the connection
                        proxy, if used
                </p>
            </li><li class="listitem">
                <p title="'http.request':">
                    <b>'http.request':&nbsp;</b>
                    <code class="interfacename">HttpRequest</code> instance representing the
                        actual HTTP request.
                </p>
            </li><li class="listitem">
                <p title="'http.response':">
                    <b>'http.response':&nbsp;</b>
                    <code class="interfacename">HttpResponse</code> instance representing the
                        actual HTTP response.
                </p>
            </li><li class="listitem">
                <p title="'http.request_sent':">
                    <b>'http.request_sent':&nbsp;</b>
                    <code class="classname">java.lang.Boolean</code> object representing the flag
                        indicating whether the actual request has been fully transmitted to the
                        connection target.
                </p>
            </li></ul></div>
        <p>For instance, in order to determine the final redirect target, one can examine the
            value of the <code class="literal">http.target_host</code> attribute after the request
            execution:</p>
        <pre class="programlisting">
DefaultHttpClient httpclient = new DefaultHttpClient();

HttpContext localContext = new BasicHttpContext();
HttpGet httpget = new HttpGet("http://www.google.com/");

HttpResponse response = httpclient.execute(httpget, localContext);

HttpHost target = (HttpHost) localContext.getAttribute(
    ExecutionContext.HTTP_TARGET_HOST);

System.out.println("Final target: " + target);

HttpEntity entity = response.getEntity();
if (entity != null) {
entity.consumeContent();
}
</pre>
        <p>stdout &gt;</p>
        <pre class="programlisting">
Final target: http://www.google.ch
</pre>
    </div>
    <div class="section" title="1.3.&nbsp;Exception handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e246"></a>1.3.&nbsp;Exception handling</h2></div></div></div>
        
        <p>HttpClient can throw two types of exceptions:
                <code class="exceptionname">java.io.IOException</code> in case of an I/O failure such as
            socket timeout or an socket reset and <code class="exceptionname">HttpException</code> that
            signals an HTTP failure such as a violation of the HTTP protocol. Usually I/O errors are
            considered non-fatal and recoverable, whereas HTTP protocol errors are considered fatal
            and cannot be automatically recovered from.</p>
        <div class="section" title="1.3.1.&nbsp;HTTP transport safety"><div class="titlepage"><div><div><h3 class="title"><a name="d4e251"></a>1.3.1.&nbsp;HTTP transport safety</h3></div></div></div>
            
            <p>It is important to understand that the HTTP protocol is not well suited for all
                types of applications. HTTP is a simple request/response oriented protocol which was
                initially designed to support static or dynamically generated content retrieval. It
                has never been intended to support transactional operations. For instance, the HTTP
                server will consider its part of the contract fulfilled if it succeeds in receiving
                and processing the request, generating a response and sending a status code back to
                the client. The server will make no attempts to roll back the transaction if the
                client fails to receive the response in its entirety due to a read timeout, a
                request cancellation or a system crash. If the client decides to retry the same
                request, the server will inevitably end up executing the same transaction more than
                once. In some cases this may lead to application data corruption or inconsistent
                application state.</p>
            <p>Even though HTTP has never been designed to support transactional processing, it
                can still be used as a transport protocol for mission critical applications provided
                certain conditions are met. To ensure HTTP transport layer safety the system must
                ensure the idempotency of HTTP methods on the application layer.</p>
        </div>
        <div class="section" title="1.3.2.&nbsp;Idempotent methods"><div class="titlepage"><div><div><h3 class="title"><a name="d4e255"></a>1.3.2.&nbsp;Idempotent methods</h3></div></div></div>
            
            <p>HTTP/1.1 specification defines idempotent method as</p>
            <p>
                [<span class="citation">Methods can also have the property of "idempotence" in
                    that (aside from error or expiration issues) the side-effects of N &gt; 0
                    identical requests is the same as for a single request</span>]
            </p>
            <p>In other words the application ought to ensure that it is prepared to deal with
                the implications of multiple execution of the same method. This can be achieved, for
                instance, by providing a unique transaction id and by other means of avoiding
                execution of the same logical operation.</p>
            <p>Please note that this problem is not specific to HttpClient. Browser based
                applications are subject to exactly the same issues related to HTTP methods
                non-idempotency.</p>
            <p>HttpClient assumes non-entity enclosing methods such as <code class="literal">GET</code> and
                    <code class="literal">HEAD</code> to be idempotent and entity enclosing methods such as
                    <code class="literal">POST</code> and <code class="literal">PUT</code> to be not.</p>
        </div>
        <div class="section" title="1.3.3.&nbsp;Automatic exception recovery"><div class="titlepage"><div><div><h3 class="title"><a name="d4e267"></a>1.3.3.&nbsp;Automatic exception recovery</h3></div></div></div>
            
            <p>By default HttpClient attempts to automatically recover from I/O exceptions. The
                default auto-recovery mechanism is limited to just a few exceptions that are known
                to be safe.</p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>HttpClient will make no attempt to recover from any logical or HTTP
                        protocol errors (those derived from
                            <code class="exceptionname">HttpException</code> class).</p>
                </li><li class="listitem">
                    <p>HttpClient will automatically retry those methods that are assumed to be
                        idempotent.</p>
                </li><li class="listitem">
                    <p>HttpClient will automatically retry those methods that fail with a
                        transport exception while the HTTP request is still being transmitted to the
                        target server (i.e. the request has not been fully transmitted to the
                        server).</p>
                </li><li class="listitem">
                    <p>HttpClient will automatically retry those methods that have been fully
                        transmitted to the server, but the server failed to respond with an HTTP
                        status code (the server simply drops the connection without sending anything
                        back). In this case it is assumed that the request has not been processed by
                        the server and the application state has not changed. If this assumption may
                        not hold true for the web server your application is targeting it is highly
                        recommended to provide a custom exception handler.</p>
                </li></ul></div>
        </div>
        <div class="section" title="1.3.4.&nbsp;Request retry handler"><div class="titlepage"><div><div><h3 class="title"><a name="d4e280"></a>1.3.4.&nbsp;Request retry handler</h3></div></div></div>
            
            <p>In order to enable a custom exception recovery mechanism one should provide an
                implementation of the <code class="interfacename">HttpRequestRetryHandler</code>
                interface.</p>
            <pre class="programlisting">
DefaultHttpClient httpclient = new DefaultHttpClient();

HttpRequestRetryHandler myRetryHandler = new HttpRequestRetryHandler() {

    public boolean retryRequest(
            IOException exception, 
            int executionCount,
            HttpContext context) {
        if (executionCount &gt;= 5) {
            // Do not retry if over max retry count
            return false;
        }
        if (exception instanceof NoHttpResponseException) {
            // Retry if the server dropped connection on us
            return true;
        }
        if (exception instanceof SSLHandshakeException) {
            // Do not retry on SSL handshake exception
            return false;
        }
        HttpRequest request = (HttpRequest) context.getAttribute(
                ExecutionContext.HTTP_REQUEST);
        boolean idempotent = !(request instanceof HttpEntityEnclosingRequest); 
        if (idempotent) {
            // Retry if the request is considered idempotent 
            return true;
        }
        return false;
    }

};

httpclient.setHttpRequestRetryHandler(myRetryHandler);
</pre>
        </div>
    </div>
    <div class="section" title="1.4.&nbsp;Aborting requests"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e285"></a>1.4.&nbsp;Aborting requests</h2></div></div></div>
        
        <p>In some situations HTTP request execution fail to complete within the expected time
            frame due to high load on the target server or too many concurrent requests issued on
            the client side. In such cases it may be necessary to terminate the request prematurely
            and unblock the execution thread blocked in a I/O operation. HTTP requests being
            executed by HttpClient can be aborted at any stage of execution by invoking
                <code class="methodname">HttpUriRequest#abort()</code> method. This method is thread-safe
            and can be called from any thread. When an HTTP request is aborted its execution thread
            blocked in an I/O operation is guaranteed to unblock by throwing a
                <code class="exceptionname">InterruptedIOException</code></p>
    </div>
    <div class="section" title="1.5.&nbsp;HTTP protocol interceptors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e290"></a>1.5.&nbsp;HTTP protocol interceptors</h2></div></div></div>
        
        <p>HTTP protocol interceptor is a routine that implements a specific aspect of the HTTP
            protocol. Usually protocol interceptors are expected to act upon one specific header or
            a group of related headers of the incoming message or populate the outgoing message with
            one specific header or a group of related headers. Protocol interceptors can also
            manipulate content entities enclosed with messages, transparent content compression /
            decompression being a good example. Usually this is accomplished by using the
            'Decorator' pattern where a wrapper entity class is used to decorate the original
            entity. Several protocol interceptors can be combined to form one logical unit.</p>
        <p>Protocol interceptors can collaborate by sharing information - such as a processing
            state - through the HTTP execution context. Protocol interceptors can use HTTP context
            to store a processing state for one request or several consecutive requests.</p>
        <p>Usually the order in which interceptors are executed should not matter as long as they
            do not depend on a particular state of the execution context. If protocol interceptors
            have interdependencies and therefore must be executed in a particular order, they should
            be added to the protocol processor in the same sequence as their expected execution
            order.</p>
        <p>Protocol interceptors must be implemented as thread-safe. Similarly to servlets,
            protocol interceptors should not use instance variables unless access to those variables
            is synchronized.</p>
        <p>This is an example of how local context can be used to persist a processing state
            between consecutive requests:</p>
        <pre class="programlisting">
DefaultHttpClient httpclient = new DefaultHttpClient();

HttpContext localContext = new BasicHttpContext();

AtomicInteger count = new AtomicInteger(1);

localContext.setAttribute("count", count);

httpclient.addRequestInterceptor(new HttpRequestInterceptor() {

    public void process(
            final HttpRequest request, 
            final HttpContext context) throws HttpException, IOException {
        AtomicInteger count = (AtomicInteger) context.getAttribute("count");
        request.addHeader("Count", Integer.toString(count.getAndIncrement()));
    }
    
});

HttpGet httpget = new HttpGet("http://localhost/");
for (int i = 0; i &lt; 10; i++) {
    HttpResponse response = httpclient.execute(httpget, localContext);
    
    HttpEntity entity = response.getEntity();
    if (entity != null) {
        entity.consumeContent();
    }
}
</pre>
    </div>
    <div class="section" title="1.6.&nbsp;HTTP parameters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e298"></a>1.6.&nbsp;HTTP parameters</h2></div></div></div>
        
        <p>HttpParams interface represents a collection of immutable values that define a runtime
            behavior of a component. In many ways <code class="interfacename">HttpParams</code> is
            similar to <code class="interfacename">HttpContext</code>. The main distinction between the
            two lies in their use at runtime. Both interfaces represent a collection of objects that
            are organized as a map of keys to object values, but serve distinct purposes:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p><code class="interfacename">HttpParams</code> is intended to contain simple
                    objects: integers, doubles, strings, collections and objects that remain
                    immutable at runtime.</p>
            </li><li class="listitem">
                <p>
                    <code class="interfacename">HttpParams</code> is expected to be used in the 'write
                    once - ready many' mode. <code class="interfacename">HttpContext</code> is intended
                    to contain complex objects that are very likely to mutate in the course of HTTP
                    message processing. </p>
            </li><li class="listitem">
                <p>The purpose of <code class="interfacename">HttpParams</code> is to define a
                    behavior of other components. Usually each complex component has its own
                        <code class="interfacename">HttpParams</code> object. The purpose of
                        <code class="interfacename">HttpContext</code> is to represent an execution
                    state of an HTTP process. Usually the same execution context is shared among
                    many collaborating objects.</p>
            </li></ul></div>
        <div class="section" title="1.6.1.&nbsp;Parameter hierarchies"><div class="titlepage"><div><div><h3 class="title"><a name="d4e316"></a>1.6.1.&nbsp;Parameter hierarchies</h3></div></div></div>
            
            <p>In the course of HTTP request execution <code class="interfacename">HttpParams</code>
                of the <code class="interfacename">HttpRequest</code> object are linked together with
                    <code class="interfacename">HttpParams</code> of the
                    <code class="interfacename">HttpClient</code> instance used to execute the request.
                This enables parameters set at the HTTP request level take precedence over
                    <code class="interfacename">HttpParams</code> set at the HTTP client level. The
                recommended practice is to set common parameters shared by all HTTP requests at the
                HTTP client level and selectively override specific parameters at the HTTP request
                level.</p>
            <pre class="programlisting">
DefaultHttpClient httpclient = new DefaultHttpClient();
httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, 
    HttpVersion.HTTP_1_0);
httpclient.getParams().setParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET, 
    "UTF-8");

HttpGet httpget = new HttpGet("http://www.google.com/");
httpget.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, 
    HttpVersion.HTTP_1_1);
httpget.getParams().setParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, 
    Boolean.FALSE);

httpclient.addRequestInterceptor(new HttpRequestInterceptor() {

    public void process(
            final HttpRequest request, 
            final HttpContext context) throws HttpException, IOException {
        System.out.println(request.getParams().getParameter(
                CoreProtocolPNames.PROTOCOL_VERSION));
        System.out.println(request.getParams().getParameter(
                CoreProtocolPNames.HTTP_CONTENT_CHARSET));
        System.out.println(request.getParams().getParameter(
                CoreProtocolPNames.USE_EXPECT_CONTINUE));
        System.out.println(request.getParams().getParameter(
                CoreProtocolPNames.STRICT_TRANSFER_ENCODING));
    }
    
});
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
HTTP/1.1
UTF-8
false
null
</pre>
        </div>
        <div class="section" title="1.6.2.&nbsp;HTTP parameters beans"><div class="titlepage"><div><div><h3 class="title"><a name="d4e327"></a>1.6.2.&nbsp;HTTP parameters beans</h3></div></div></div>
            
            <p><code class="interfacename">HttpParams</code> interface allows for a great deal of
                flexibility in handling configuration of components. Most importantly, new
                parameters can be introduced without affecting binary compatibility with older
                versions. However, <code class="interfacename">HttpParams</code> also has a certain
                disadvantage compared to regular Java beans:
                    <code class="interfacename">HttpParams</code> cannot be assembled using a DI
                framework. To mitigate the limitation, HttpClient includes a number of bean classes
                that can used in order to initialize <code class="interfacename">HttpParams</code>
                objects using standard Java bean conventions.</p>
            <pre class="programlisting">
HttpParams params = new BasicHttpParams();
HttpProtocolParamBean paramsBean = new HttpProtocolParamBean(params);
paramsBean.setVersion(HttpVersion.HTTP_1_1);
paramsBean.setContentCharset("UTF-8");
paramsBean.setUseExpectContinue(true);

System.out.println(params.getParameter(
    CoreProtocolPNames.PROTOCOL_VERSION));
System.out.println(params.getParameter(
    CoreProtocolPNames.HTTP_CONTENT_CHARSET));
System.out.println(params.getParameter(
    CoreProtocolPNames.USE_EXPECT_CONTINUE));
System.out.println(params.getParameter(
    CoreProtocolPNames.USER_AGENT));
</pre>
            <p>stdout &gt;</p>
            <pre class="programlisting">
HTTP/1.1
UTF-8
false
null
</pre>
        </div>
    </div>
    <div class="section" title="1.7.&nbsp;HTTP request execution parameters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e337"></a>1.7.&nbsp;HTTP request execution parameters</h2></div></div></div>
        
        <p>These are parameters that can impact the process of request execution:</p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p title="'http.protocol.version':">
                    <b>'http.protocol.version':&nbsp;</b>
                    defines HTTP protocol version used if not set explicitly on the request
                        object. This parameter expects a value of type
                            <code class="interfacename">ProtocolVersion</code>. If this parameter is not
                        set HTTP/1.1 will be used.
                </p>
            </li><li class="listitem">
                <p title="'http.protocol.element-charset':">
                    <b>'http.protocol.element-charset':&nbsp;</b>
                    defines the charset to be used for encoding HTTP protocol elements. This
                        parameter expects a value of type <code class="classname">java.lang.String</code>.
                        If this parameter is not set <code class="literal">US-ASCII</code> will be
                        used.
                </p>
            </li><li class="listitem">
                <p title="'http.protocol.content-charset':">
                    <b>'http.protocol.content-charset':&nbsp;</b>
                    defines the charset to be used per default for content body coding. This
                        parameter expects a value of type <code class="classname">java.lang.String</code>.
                        If this parameter is not set <code class="literal">ISO-8859-1</code> will be
                        used.
                </p>
            </li><li class="listitem">
                <p title="'http.useragent':">
                    <b>'http.useragent':&nbsp;</b>
                    defines the content of the <code class="literal">User-Agent</code> header. This
                        parameter expects a value of type <code class="classname">java.lang.String</code>.
                        If this parameter is not set, HttpClient will automatically generate a value
                        for it.
                </p>
            </li><li class="listitem">
                <p title="'http.protocol.strict-transfer-encoding':">
                    <b>'http.protocol.strict-transfer-encoding':&nbsp;</b>
                    defines whether responses with an invalid
                            <code class="literal">Transfer-Encoding</code> header should be rejected. This
                        parameter expects a value of type <code class="classname">java.lang.Boolean</code>.
                        If this parameter is not set invalid <code class="literal">Transfer-Encoding</code>
                        values will be ignored.
                </p>
            </li><li class="listitem">
                <p title="'http.protocol.expect-continue':">
                    <b>'http.protocol.expect-continue':&nbsp;</b>
                    activates <code class="literal">Expect: 100-Continue</code> handshake for the entity
                        enclosing methods. The purpose of the <code class="literal">Expect:
                            100-Continue</code> handshake is to allow the client that is sending
                        a request message with a request body to determine if the origin server is
                        willing to accept the request (based on the request headers) before the
                        client sends the request body. The use of the <code class="literal">Expect:
                            100-continue</code> handshake can result in a noticeable performance
                        improvement for entity enclosing requests (such as <code class="literal">POST</code>
                        and <code class="literal">PUT</code>) that require the target server's authentication.
                            <code class="literal">Expect: 100-continue</code> handshake should be used with
                        caution, as it may cause problems with HTTP servers and proxies that do not
                        support HTTP/1.1 protocol. This parameter expects a value of type
                            <code class="classname">java.lang.Boolean</code>. If this parameter is not set
                        HttpClient will attempt to use the handshake.
                </p>
            </li><li class="listitem">
                <p title="'http.protocol.wait-for-continue':">
                    <b>'http.protocol.wait-for-continue':&nbsp;</b>
                    defines the maximum period of time in milliseconds the client should spend
                        waiting for a <code class="literal">100-continue</code> response. This parameter
                        expects a value of type <code class="classname">java.lang.Integer</code>. If this
                        parameter is not set HttpClient will wait 3 seconds for a confirmation
                        before resuming the transmission of the request body.
                </p>
            </li></ul></div>
    </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="preface.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="connmgmt.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Preface&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;Connection management</td></tr></table></div></body></html>